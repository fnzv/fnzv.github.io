{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/blog/2018-05-27-loadstressing-from-cloud","result":{"data":{"site":{"siteMetadata":{"title":"sami.pw","siteUrl":"https://sami.pw"}},"markdownRemark":{"html":"<p>Today i finally decided to opensource some of my code created to reach my maximum level of lazyness, Automatically loadstressing web infrastructures via Telegram. <br>\nThe other challenge was to see/prove if Golang can be a replacement/alternative for Python scripting.<br><br></p>\n<p>Repo: <a href='https://github.com/fnzv/DTBOT'>https://github.com/fnzv/DTBOT</a></p>\n<p>Here is the diagram to better explain what i wanted to do:</p>\n<p><img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/master/imgs/dtbot-diagram.png\">\n<br>\n<em>Disclaimer before i even start</em> <br>\nI'm not responsible for anything you do with this tool, this was made only for legit web loadstressing/benchmarking YOUR OWN infra. <br>\nI know that most of the code can be written more efficently/well, don't hate on my exec_shell() ahah  <br>\n<em>end of disclamer</em> <br></p>\n<p><br><br><br> </p>\n<h2>The main \"ingredients\" are:</h2>\n<ul>\n<li>Ansible <br></li>\n<li>Golang <br></li>\n<li>Telegram <br></li>\n<li>At least one cloud provider with some resources <br>\n<br><br></li>\n</ul>\n<p>It all starts from the Telegram Bot that keeps listening commands from the allowed \"chat_id\" configured and whenever a predefined command is sent the bot (Written in Golang) runs the Ansible playbook with extra args and gives feedback\nto the user via Telegram. <br></p>\n<p>This is a classic example for load stressing from Openstack using DTBOT: <br></p>\n<ol>\n<li>User writes to Loadstresser bot chat \"/create 5\" which triggers the bot to execute the underlying Ansible playbook to deploy 5 VMs on the Openstack Configured Credendials. <br>\nIf you check the logs (/var/log/dtbot.log) with a small Ansible background you can understand what's really happening:  <br>\n<code class=\"language-text\">2018/05/19 14:35:46 Command: source /etc/dtbot/os_creds &amp;&amp; ansible_python_interpreter=/usr/bin/python3 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -vv /etc/dtbot/playbooks/create-infra.yaml --extra-vars=&quot;total_nodes=5 telegramtoken=botTOKEN telegramchatid=CHATID&quot;</code></li>\n<li>After a few minutes User recieves feedback that VMs are ready and can start loadstressing with: <code class=\"language-text\">/load http://example.org &lt;Num clients&gt; &lt;Num VMs involved&gt; &lt;Time in seconds&gt;</code>  <br></li>\n</ol>\n<p>The defined command /load was created for simplicity and uses WRK (<a href=\"https://github.com/wg/wrk\">https://github.com/wg/wrk</a>) as a stresser which works great out of the box without complex configuration files. <br></p>\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/master/imgs/dtbot-telegram.jpg?raw=true\" width=\"260\" height=\"500\" alt=\"Sublime&apos;s custom image\">\n</p>\n<p>After some time passed loadstressing i decided to add a bit of complexity with Jmeter configurations and custom bash scripts so any User can configure or use it's own loadstressing tool (jmeter, vegeta, nghttp2, locust.io ..). <br><br></p>\n<p>The defined commands for custom Jmeter scripts are /loadj (Openstack) and /loadj_aws (AWS) which follows the exact previous work flow (Telegram -> Golang -> Ansible) but loads a remote configuration file (.jmx in case of Jmeter) and executes the tool with the custom configuration file.  <br></p>\n<p>Note: The remote configuration file must be RAW (gist/any pastebin can be used for this). <br></p>\n<p>Example: /loadj <Remote Jmeter RAW configuration> <Number of Openstack nodes to use>  or /loadj_aws <Remote Jmeter RAW configuration> (to run jmx conf on all AWS nodes) <br></p>\n<p>You can find a simple .jmx example inside the repo under examples/ <br></p>\n<p>If you reached that point and you still asking what DT stands for.. well it's just \"DownTime\" :) <br></p>\n<p><br><br></p>\n<h2>Brief How To/Usage (more info on github repo):</h2>\n<ol>\n<li>Create a bot and save the bot Token, you can do it by writing \"/newbot\" to BotFather (<a href=\"https://telegram.me/botfather\">https://telegram.me/botfather</a>)</li>\n<li>\n<p>Use the Quick-Install of dtbot on a Ubuntu 16.04 machine and configure it.\nRequired configuration files are located under <code class=\"language-text\">/etc/dtbot/</code> : <br></p>\n<ul>\n<li>dtbot.conf ( Chat ID and Telegram Token, to find what chat id you have just write some messages to your bot and then open from the browser this url: <a href=\"https://api.telegram.org/bot\">https://api.telegram.org/bot</a><token>/getUpdates ) <br></li>\n<li>os_creds (if you want to create VMs on the Openstack Provider) - Openstack credential source file <br></li>\n<li>aws_creds` (if you want to create VMs on AWS) - AWS ACCESS and SECRET key source file (you just need the exports for those enviroment variables) <br></li>\n</ul>\n</li>\n<li>(re)start dtbot via systemd: service dtbot restart <br>\nIf everything is fine you should see \"Authorized on account BOT_NAME\" on /var/log/dtbot <br></li>\n</ol>\n<p>3.5) Take some time to adjust the Ansible Playbooks based on your cloud enviroment (AWS or Openstack): <br></p>\n<ul>\n<li><code class=\"language-text\">/etc/dtbot/playbooks/aws-create-infra.yaml</code> - You can keep it as-is but you need to change the \"key_name:\" with one present in your account, this VM should be able to SSH into newly created AWS instances with this key so generate a new key on the machine and add it to AWS) <br></li>\n<li><code class=\"language-text\">/etc/dtbot/playbooks/create-infra.yaml</code> - The only part that needs to be changes is the \"flavor:\" and \"image:\" name wich changes based on the Openstack provider <br></li>\n<li>Other changes that might be done are always the same but on also the other playbooks: info.yaml,ddos.yaml (Openstack flavor,image) <br></li>\n<li>\n<p>Try to send some commands to your Telegram Bot:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/help - shows the command list\n/create N - Deploys N VMs on Openstack, multiple runs won&#39;t deploy more VMs but just checks is N VM is present\n/create_aws N - Deploys N VM on AWS, multiple runs will deploy more VMs\n/stop N - Stops loadstressing tasks on N VMs (Openstack)\n/stop_aws - Stops all loadstressing tasks on ALL AWS VMs \n/destroy N - Deletes N VMs created on Openstack (0 to N)\n/destroy_aws - Deletes ALL loadstressing VMs created on AWS (Will just shutoff all VMs accessible by the dtbot key and therefore will be deleted because of &#39;delete on shutoff&#39;)\n/load &lt;URL&gt; &lt;Num clients&gt; &lt;Num VMs involved&gt; &lt;Time in seconds&gt; - Start load stressing on Openstack N VMs\n/load_aws &lt;URL&gt; &lt;Num clients&gt; &lt;Time in seconds&gt; - Start load stressing on ALL AWS create VMs\n/loadj &lt;URL&gt; &lt;Num VMs involved&gt; - Executes given JMX Jmeter script on N VMs (Openstack), URL must be raw and displaying directly the text\n/loadj_aws &lt;URL&gt; - Executes given JMX Jmeter script on all AWS VMs, URL must be raw and displaying directly the text\n/load_custom &lt;URL&gt; &lt;Total nodes&gt; - Executes custom bash script provided on Openstack VMs, URL must be raw and displaying directly the text\n/load_custom_aws &lt;URL&gt; - Executes custom bash script provided on all AWS VMs, URL must be raw and displaying directly the text\n/info N - Gathers info on N VMs on Openstack (Established connections and ifconfig stats), useful to check current stresstest status. (Example: start /load then after all the VMs started check /info N to see stats/data)</code></pre></div>\n</li>\n<li>Start loadstressing and tune your infra cache,db &#x26; webserver... repeat :) <br><br>\n<img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/master/imgs/dtbot-requests.png\"></li>\n</ul>\n<p>Pro-Tips:</p>\n<ul>\n<li>The bot can be added to Telegram Groups and accept commands from all members of the group, just find out the chat_id of the group and add it into the dtbot.conf</li>\n<li>Check the logs on /var/log/dtbot.log to see what's happening and in case change parameters/values on ansible playbooks.</li>\n<li>Execute manually Ansible on the dtbot VM to see if something is wrong (ansible-playbook -vv, you can copy/paste the command from the logs)</li>\n<li>On AWS use a different region from your production env</li>\n</ul>","frontmatter":{"date":"May 27, 2018","path":"/blog/2018-05-27-loadstressing-from-cloud","tags":"ddos","title":"Loadstressing from the cloud with DTBOT"}}},"pageContext":{"refPath":"/blog/2018-05-27-loadstressing-from-cloud","prev":{"frontmatter":{"title":"Monitoring trains the sysadmin way","path":"/blog/2018-03-10-Monitoring-trains"}},"next":{"frontmatter":{"title":"Automatic failover using Interlock + CI/CD(s)","path":"/blog/2020-05-30-automatic-failover-interlock"}}}}}