{"componentChunkName":"component---src-templates-tags-jsx","path":"/tag/ddos","result":{"data":{"site":{"siteMetadata":{"title":"sami.pw"}}},"pageContext":{"posts":[{"html":"<p>Today i finally decided to opensource some of my code created to reach my maximum level of lazyness, Automatically loadstressing web infrastructures via Telegram. <br>\nThe other challenge was to see/prove if Golang can be a replacement/alternative for Python scripting.<br><br></p>\n<p>Repo: <a href='https://github.com/fnzv/DTBOT'>https://github.com/fnzv/DTBOT</a></p>\n<p>Here is the diagram to better explain what i wanted to do:</p>\n<p><img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/master/imgs/dtbot-diagram.png\">\n<br>\n<em>Disclaimer before i even start</em> <br>\nI'm not responsible for anything you do with this tool, this was made only for legit web loadstressing/benchmarking YOUR OWN infra. <br>\nI know that most of the code can be written more efficently/well, don't hate on my exec_shell() ahah  <br>\n<em>end of disclamer</em> <br></p>\n<p><br><br><br> </p>\n<h2>The main \"ingredients\" are:</h2>\n<ul>\n<li>Ansible <br></li>\n<li>Golang <br></li>\n<li>Telegram <br></li>\n<li>At least one cloud provider with some resources <br>\n<br><br></li>\n</ul>\n<p>It all starts from the Telegram Bot that keeps listening commands from the allowed \"chat_id\" configured and whenever a predefined command is sent the bot (Written in Golang) runs the Ansible playbook with extra args and gives feedback\nto the user via Telegram. <br></p>\n<p>This is a classic example for load stressing from Openstack using DTBOT: <br></p>\n<ol>\n<li>User writes to Loadstresser bot chat \"/create 5\" which triggers the bot to execute the underlying Ansible playbook to deploy 5 VMs on the Openstack Configured Credendials. <br>\nIf you check the logs (/var/log/dtbot.log) with a small Ansible background you can understand what's really happening:  <br>\n<code class=\"language-text\">2018/05/19 14:35:46 Command: source /etc/dtbot/os_creds &amp;&amp; ansible_python_interpreter=/usr/bin/python3 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -vv /etc/dtbot/playbooks/create-infra.yaml --extra-vars=&quot;total_nodes=5 telegramtoken=botTOKEN telegramchatid=CHATID&quot;</code></li>\n<li>After a few minutes User recieves feedback that VMs are ready and can start loadstressing with: <code class=\"language-text\">/load http://example.org &lt;Num clients&gt; &lt;Num VMs involved&gt; &lt;Time in seconds&gt;</code>  <br></li>\n</ol>\n<p>The defined command /load was created for simplicity and uses WRK (<a href=\"https://github.com/wg/wrk\">https://github.com/wg/wrk</a>) as a stresser which works great out of the box without complex configuration files. <br></p>\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/master/imgs/dtbot-telegram.jpg?raw=true\" width=\"260\" height=\"500\" alt=\"Sublime&apos;s custom image\">\n</p>\n<p>After some time passed loadstressing i decided to add a bit of complexity with Jmeter configurations and custom bash scripts so any User can configure or use it's own loadstressing tool (jmeter, vegeta, nghttp2, locust.io ..). <br><br></p>\n<p>The defined commands for custom Jmeter scripts are /loadj (Openstack) and /loadj_aws (AWS) which follows the exact previous work flow (Telegram -> Golang -> Ansible) but loads a remote configuration file (.jmx in case of Jmeter) and executes the tool with the custom configuration file.  <br></p>\n<p>Note: The remote configuration file must be RAW (gist/any pastebin can be used for this). <br></p>\n<p>Example: /loadj <Remote Jmeter RAW configuration> <Number of Openstack nodes to use>  or /loadj_aws <Remote Jmeter RAW configuration> (to run jmx conf on all AWS nodes) <br></p>\n<p>You can find a simple .jmx example inside the repo under examples/ <br></p>\n<p>If you reached that point and you still asking what DT stands for.. well it's just \"DownTime\" :) <br></p>\n<p><br><br></p>\n<h2>Brief How To/Usage (more info on github repo):</h2>\n<ol>\n<li>Create a bot and save the bot Token, you can do it by writing \"/newbot\" to BotFather (<a href=\"https://telegram.me/botfather\">https://telegram.me/botfather</a>)</li>\n<li>\n<p>Use the Quick-Install of dtbot on a Ubuntu 16.04 machine and configure it.\nRequired configuration files are located under <code class=\"language-text\">/etc/dtbot/</code> : <br></p>\n<ul>\n<li>dtbot.conf ( Chat ID and Telegram Token, to find what chat id you have just write some messages to your bot and then open from the browser this url: <a href=\"https://api.telegram.org/bot\">https://api.telegram.org/bot</a><token>/getUpdates ) <br></li>\n<li>os_creds (if you want to create VMs on the Openstack Provider) - Openstack credential source file <br></li>\n<li>aws_creds` (if you want to create VMs on AWS) - AWS ACCESS and SECRET key source file (you just need the exports for those enviroment variables) <br></li>\n</ul>\n</li>\n<li>(re)start dtbot via systemd: service dtbot restart <br>\nIf everything is fine you should see \"Authorized on account BOT_NAME\" on /var/log/dtbot <br></li>\n</ol>\n<p>3.5) Take some time to adjust the Ansible Playbooks based on your cloud enviroment (AWS or Openstack): <br></p>\n<ul>\n<li><code class=\"language-text\">/etc/dtbot/playbooks/aws-create-infra.yaml</code> - You can keep it as-is but you need to change the \"key_name:\" with one present in your account, this VM should be able to SSH into newly created AWS instances with this key so generate a new key on the machine and add it to AWS) <br></li>\n<li><code class=\"language-text\">/etc/dtbot/playbooks/create-infra.yaml</code> - The only part that needs to be changes is the \"flavor:\" and \"image:\" name wich changes based on the Openstack provider <br></li>\n<li>Other changes that might be done are always the same but on also the other playbooks: info.yaml,ddos.yaml (Openstack flavor,image) <br></li>\n<li>\n<p>Try to send some commands to your Telegram Bot:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/help - shows the command list\n/create N - Deploys N VMs on Openstack, multiple runs won&#39;t deploy more VMs but just checks is N VM is present\n/create_aws N - Deploys N VM on AWS, multiple runs will deploy more VMs\n/stop N - Stops loadstressing tasks on N VMs (Openstack)\n/stop_aws - Stops all loadstressing tasks on ALL AWS VMs \n/destroy N - Deletes N VMs created on Openstack (0 to N)\n/destroy_aws - Deletes ALL loadstressing VMs created on AWS (Will just shutoff all VMs accessible by the dtbot key and therefore will be deleted because of &#39;delete on shutoff&#39;)\n/load &lt;URL&gt; &lt;Num clients&gt; &lt;Num VMs involved&gt; &lt;Time in seconds&gt; - Start load stressing on Openstack N VMs\n/load_aws &lt;URL&gt; &lt;Num clients&gt; &lt;Time in seconds&gt; - Start load stressing on ALL AWS create VMs\n/loadj &lt;URL&gt; &lt;Num VMs involved&gt; - Executes given JMX Jmeter script on N VMs (Openstack), URL must be raw and displaying directly the text\n/loadj_aws &lt;URL&gt; - Executes given JMX Jmeter script on all AWS VMs, URL must be raw and displaying directly the text\n/load_custom &lt;URL&gt; &lt;Total nodes&gt; - Executes custom bash script provided on Openstack VMs, URL must be raw and displaying directly the text\n/load_custom_aws &lt;URL&gt; - Executes custom bash script provided on all AWS VMs, URL must be raw and displaying directly the text\n/info N - Gathers info on N VMs on Openstack (Established connections and ifconfig stats), useful to check current stresstest status. (Example: start /load then after all the VMs started check /info N to see stats/data)</code></pre></div>\n</li>\n<li>Start loadstressing and tune your infra cache,db &#x26; webserver... repeat :) <br><br>\n<img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/master/imgs/dtbot-requests.png\"></li>\n</ul>\n<p>Pro-Tips:</p>\n<ul>\n<li>The bot can be added to Telegram Groups and accept commands from all members of the group, just find out the chat_id of the group and add it into the dtbot.conf</li>\n<li>Check the logs on /var/log/dtbot.log to see what's happening and in case change parameters/values on ansible playbooks.</li>\n<li>Execute manually Ansible on the dtbot VM to see if something is wrong (ansible-playbook -vv, you can copy/paste the command from the logs)</li>\n<li>On AWS use a different region from your production env</li>\n</ul>","id":"248fee8d-33c2-5b26-b332-63b34293213c","timeToRead":5,"frontmatter":{"date":"May 27, 2018","path":"/blog/2018-05-27-loadstressing-from-cloud","tags":"ddos","title":"Loadstressing from the cloud with DTBOT"}},{"html":"<p><img src=\"https://raw.githubusercontent.com/fnzv/fnzv.github.io/5653b21f4114429a5bddf86aaed7891fb3a1e542/imgs/ddos-warz.gif\">\nRecently i was researching a lot on the various denial of service attacks and how to mitigate them from Layer 1 to 7 and as always the most convinient way to stop any attacks is keeping the bad requests/traffic away from your services starting from the first layers of the ISO/OSI model.<br></p>\n<h4>Realistically the only ways to prevent DDoS attacks are:<br></h4>\n<p>a) Layer 3-4 mitigation with <strong>BGP/Cloud</strong> Scrubbing (Sending all your network traffic using BGP or 'sophisticated' VPNs to third-party POP's to delegate attack mitigation).<br></p>\n<ul>\n<li>Pros: This is the only and smart way to properly mitigating attacks, your services won't be hit by attacks/malicious traffic.</li>\n<li>Cons: Paying an External Provider &#x26; bandwidth costs, All your traffic is re-routed so latency, packetloss and any other network issue that could happen to the External Provider affects you directly....And yes there could be false positives and customers may be locked out of their services.<br><br><br></li>\n</ul>\n<p>b) DNS Obfuscation/<strong>CDN Mitigation</strong>/Proxying only legit requests, a well-known example is CloudFlare  (Kinda like Security through Obfuscation.. and it works only if you have certain services and know your stuff.)<br></p>\n<ul>\n<li>Pros: If you only have HTTP(S) services exposed this is a great option and it's cheap or free.. (you can also setup your own private proxying with Nginx on some VPS/Cloud provider with DDoS protection). <br></li>\n<li>Cons: Doesn't work well if you have other exposed services like Email servers,FTP or any dedicated exposed network assigned to you (Example.. if you are a Carrier you can't just hide your site using DNS since they will hit your announced AS networks...)\n<br><br><br></li>\n</ul>\n<p>c) <strong>Layer 6-7 mitigation</strong> using server/service side counter-measures (enabling Nginx rate limiting, Cache filtering, Apache mod<em>security &#x26; mod</em>evasive bans ..)<br></p>\n<ul>\n<li>Pros: Easily to configure and some low-end attacks can be mitigated (example: Website scans, Automated Bots/Aggressive crawlers..)<br></li>\n<li>Cons: A real attack will saturate your uplink and bring you down all your services<br><br><br></li>\n</ul>\n<p>d) <strong>DIY DDoS protection</strong> using Linux boxes and the good old packet filter.<br></p>\n<ul>\n<li>Pros: It's free, it just works, you need only to create your own \"patterns\" and attack/network blacklists.<br></li>\n<li>Cons: You need to have at least 100G Uplinks and expesive dedicated servers to process all fast incoming/outgoing traffic, you have to manage all the network issues your self and if you saturate your links with the upstream BGP provider they may drop your traffic and/or blackhole you anyways as no one wants unwanted bandwidth costs &#x26; saturated links by malicious traffic or bogus packets.<br><br><br></li>\n</ul>\n<p>Before do you even think of option d) watch this:<br><br>\n<img src=\"https://github.com/fnzv/fnzv.github.io/blob/beedd3afa60078ac41b7b574738a22f690bec90a/ddos-fish.gif?raw=true\">\n<br><br></p>\n<p>Cool, but how i detect attacks?  Well if you have $$ and you only believe enterprise stuff <br><br>\n--> grab that 500+ grand network box and put it in front of your DC... whereas if you are an opensource guy you can go for FastNetMon (By Pavel Odintsov) and setup your own Anti-DDoS detection/mitigation solution.<br>\n<br><br></p>\n<h4>What is FastNetMon?<br><br></h4>\n<p>FastNetMon is <strong>DDoS analyzer</strong> that will let you to detect nearly realtime attacks or suspicious traffic (example: VPS X is compromised and starts doing SYN Flood vs outbound nets --> detected and alerted by FNM), FNM isn't just a <br>\ndetection tool but also helps to mitigate attacks, after the ban rule is triggered a bash script is being executed (there are also a lot of 'extra' stuff to do.. Slack webhooks..Keep a track of Influx metircs..Email Alerts...Send an emergency call/SMS..BGP Announce...Shutoff the VPS)<br>\n<br><br>\nScenario 1:<br>\nVPS provider on Hypervisor X protects customers with FNM and when an attacks is detected on NetFlow/sFlow/IPFIX traffic the bash script automatically adds a blackhole rule on edge network device/hypervisor host to avoid degrading network performance for\nother customers<br>\n<br>\nScenario 2:<br>\nCarrier needs to monitor traffic flows on their network boxes, Set ups FNM and gather all flows to monitor subnets to re-route traffic (GoBGP &#x26; ExaBGP are supported by FNM) when links are saturated<br>\n<br>\n..<br>\n...<br>\n<br>\nAnd so on<br>\n<br></p>\n<p>The FNM setup is quite easy to get up and running, the tricky part is setting up Grafana,Influxdb metrics but that's not a problem if you are interested only in detection/mitigation.<br>\nIf you are into dashboarding you could also set up an ELK (this is the icing on the cake) to gather NetFlow data and create great visualization with Kibana (Total PPS in, Top \"Talkers\" on outgoing/incoming traffic, Traffic Categories, Sort by TCP/UDP..). <br><br></p>\n<p>The only requirements are:<br></p>\n<ul>\n<li>Small Server/Virtual Machine that will recieve all the flow traffic from routers/switches via a <a href=\"https://github.com/pavel-odintsov/fastnetmon/blob/master/docs/CAPTURE_BACKENDS.md\">capture backend</a><br></li>\n<li>For automated BGP integration you need to allow the Server to talk directly to the routers/switches<br>\n<br></li>\n</ul>\n<p>Links and Resources:<br></p>\n<ul>\n<li><a href=\"https://github.com/pavel-odintsov/fastnetmon/tree/master/docs\">Github documentation</a><br></li>\n<li><a href=\"https://fastnetmon.com/\">FastNetMon site</a> (Thank you Pavel for this project) <br></li>\n<li><a href=\"http://pmacct.net/\">Managing Flows</a> (Great tool from Paolo Lucente) if you want to collect properly flows you can use nfacct <br><br></li>\n</ul>\n<p>For any question &#x26; discussion don't esitate contact me <br><br></p>","id":"5511e138-daf9-5a3b-87ec-c16057fef7c3","timeToRead":4,"frontmatter":{"date":"August 19, 2017","path":"/blog/2017-08-19-how-to-detect-ddos","tags":"ddos","title":"How to detect & mitigate (D)DoS Attacks using FastNetMon"}}],"tag":"ddos","pagesSum":1,"page":1}}}